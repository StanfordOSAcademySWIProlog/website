begin.
assertz(col(config,'8f38942e-9293-4f31-ac3c-7b0c17bd7420')).
assertz(eav('8f38942e-9293-4f31-ac3c-7b0c17bd7420',name,title)).
assertz(eav('8f38942e-9293-4f31-ac3c-7b0c17bd7420',value,'Untitled site')).
assertz(col(migration,'c7ff0977-65e3-457f-a241-1a615b92405b')).
assertz(eav('c7ff0977-65e3-457f-a241-1a615b92405b',description,'Inserts the initial config')).
assertz(eav('c7ff0977-65e3-457f-a241-1a615b92405b',name,bc_initial_config)).
end.
begin.
assertz(col(user,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',files,true)).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',fullname,'Admin')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',key,'a062927b-089a-4bcb-ac0f-aca58988a9e4')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',link,"")).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',password,'09bd34749085b3dd199080991c5a6d358b1e581aa5d63c8752d8c423faff1206')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',salt,'25381708-4303-4df1-aa93-1e874088ab53')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',type,admin)).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',username,'admin@example.com')).
assertz(col(migration,'62f47a3b-d743-4d62-aa6f-806e6e471b8c')).
assertz(eav('62f47a3b-d743-4d62-aa6f-806e6e471b8c',description,'Inserts the initial user')).
assertz(eav('62f47a3b-d743-4d62-aa6f-806e6e471b8c',name,bc_initial_user)).
end.
begin.
assertz(col(config,'ee83b5fe-5808-4e66-ae88-6e216594c4a2')).
assertz(eav('ee83b5fe-5808-4e66-ae88-6e216594c4a2',name,default_language)).
assertz(eav('ee83b5fe-5808-4e66-ae88-6e216594c4a2',value,en)).
assertz(col(migration,'9e78bf1d-0079-4e94-afc0-54fb52fe2753')).
assertz(eav('9e78bf1d-0079-4e94-afc0-54fb52fe2753',description,'Adds language to posts')).
assertz(eav('9e78bf1d-0079-4e94-afc0-54fb52fe2753',name,bc_add_language)).
end.
begin.
assertz(col(config,'46081e67-ba6e-4983-a778-8396659cc206')).
assertz(eav('46081e67-ba6e-4983-a778-8396659cc206',name,smtp_enabled)).
assertz(eav('46081e67-ba6e-4983-a778-8396659cc206',value,false)).
assertz(col(config,'725dbd62-1e3f-4c6a-a8ee-d1dc8c22b6db')).
assertz(eav('725dbd62-1e3f-4c6a-a8ee-d1dc8c22b6db',name,smtp_host)).
assertz(eav('725dbd62-1e3f-4c6a-a8ee-d1dc8c22b6db',value,localhost)).
assertz(col(config,'ceb0a1a4-efd6-4cc8-a3c0-9e813b994c15')).
assertz(eav('ceb0a1a4-efd6-4cc8-a3c0-9e813b994c15',name,smtp_user)).
assertz(eav('ceb0a1a4-efd6-4cc8-a3c0-9e813b994c15',value,user)).
assertz(col(config,'7604dd4d-8e30-40c4-ae0b-23b3f05660c6')).
assertz(eav('7604dd4d-8e30-40c4-ae0b-23b3f05660c6',name,smtp_password)).
assertz(eav('7604dd4d-8e30-40c4-ae0b-23b3f05660c6',value,password)).
assertz(col(config,'734bcc37-b5ce-4f62-ac7c-6b6a1bb9ea49')).
assertz(eav('734bcc37-b5ce-4f62-ac7c-6b6a1bb9ea49',name,smtp_auth)).
assertz(eav('734bcc37-b5ce-4f62-ac7c-6b6a1bb9ea49',value,login)).
assertz(col(migration,'6b37e35d-3917-42e7-a786-d70a04ac92f6')).
assertz(eav('6b37e35d-3917-42e7-a786-d70a04ac92f6',description,'Adds SMTP settings')).
assertz(eav('6b37e35d-3917-42e7-a786-d70a04ac92f6',name,bc_smtp_settings)).
end.
begin.
assertz(col(entry,'4fe426fe-9032-4661-aeb0-18be269670dd')).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',commenting,true)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',content,"My first Blog-Core site")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',content_type,markdown)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',date_updated,1421884800)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',description,"")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',html,"\n\n<p>\nMy first Blog-Core site</p>")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',language,"en")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',published,false)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',slug,about)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',tags,[])).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',title,"About")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',type,block)).
end.
begin.
assertz(col(entry,'88daf9ee-74b1-40cc-a3f3-a867cfbfb398')).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',commenting,true)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"Hello World")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content_type,markdown)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1421884800)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',description,"")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"\n\n<p>\nHello World</p>")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',language,"en")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',published,false)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',slug,hello)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',tags,[])).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',title,"hello")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',type,page)).
end.
begin.
assertz(col(user,'d9556236-364e-4796-a7e8-3337e82660f3')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',files,true)).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',fullname,'Yingbai He')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',key,'c3ff8e02-9bd2-474f-a2a6-fa38e1101bdb')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',link,"")).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',password,f455a78de278c5d54d32220e4a18477ef2cec14bf621ed4ff6849621b1f1bb68)).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',salt,'193d8e04-c862-4e12-af29-b4ddc8f0b50a')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',type,admin)).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',username,'hyb175@qq.com')).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,_G2756)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1422835200)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',slug,_G2756)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',slug,tutorial)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',title,_G2756)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',title,"Tutorial")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G53696)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t\t<TITLE>Your Title Here</TITLE>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G53696)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t\t<TITLE>Your Title Here</TITLE>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t</BODY>\n</HTML>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G19429)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G19429)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G10020)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G10020)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G5506)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G5506)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G8092)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</code></p>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G8092)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/code&gt;&lt;/p&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G10567)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</code>\n\n\t\t<code>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\t</code>\n\t\t\t\n\t\t<code>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G10567)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</code>\n\n<pre>\n<code>\t&lt;code&gt;\n\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t&lt;/code&gt;\n\t\t\n\t&lt;code&gt;\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G9665)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G9665)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/pre&gt;&lt;/p&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G11751)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G11751)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\n<pre>\n<code>&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G118365)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\n\t\t\tfail.\n\n\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\n\t\t\tfail.\n\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\n\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\n\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G118365)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/pre&gt;&lt;/p&gt;\n\t&lt;p&gt;All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.&lt;/p&gt;\n\t&lt;p&gt;Adding the initial conditions stores the initialstate as nodes in the database. &lt;/p&gt;\n\t&lt;pre&gt;\n\tadd_initial_conditions([]).\n\tadd_initial_conditions([Pred|Conditions]):-\n\t\tadd_plan_graph(0, add, Pred, start),\n\t\tadd_initial_conditions(Conditions).&lt;/pre&gt;\n\t&lt;p&gt;We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. &lt;/p&gt;\n\t&lt;p&gt;Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. &lt;/p&gt;\n\t&lt;pre&gt;\n\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\tN1 is N-1,\n\t\t%% Check if FinalState Conditions have been satisfied \n\t        %%    and no mutual exclusion conditions have been violated\n\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t!.\n\n\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t% Add no-ops\n\t\tadd_no_op_nodes(N),\n\n\t\tfail.\n\n\n\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\tcan(Action, PreConditions, Domain),\n\t\tNPrev is N-1,\n\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\n\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(DelPreConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t    )\n\t\t),\n\n\t\t\n\t\tadds(Action, AddConditions, _, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(AddConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t    )\n\t\t),\n\n\n\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t%\tnl, write(\"Added Action: \"), write(Action),\n\t%\tnl,\n\n\t\tfail.\n\n\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t% Propagate mutual exclusions\n\t\tmutex(N),\n\n\t\tN1 is N+1,\n\t\t!,\n\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t!.\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;pre&gt;\n\tPrevActions, Plan):-\n\t\tN &gt; 0,\n\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\n\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\tlist_to_set(PreConds, MidState),\n\n\t\tnl, write(' Level  '), write(N),\n\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\tN1 is N-1,\n\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.&lt;/p&gt;\n\t&lt;p&gt;The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.&lt;/p&gt;\n\t&lt;p&gt;There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.&lt;/p&gt;\n\t&lt;p&gt;Finally, we can write the plan out to the screen by write_plan/1. &lt;/p&gt;\n\t&lt;hr&gt;\n\t&lt;p&gt;We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\tThe rocket_graph contains the defintion of domain and the available actions.\n\tThis example wants to move the cargos from one city to another.\n\tWe first define the knowledge base of rocket, place and cargo.&lt;/p&gt;\n\t&lt;pre&gt;\n\tplace(london).\n\tplace(paris).\n\tcargo(a).\n\tcargo(b).\n\tcargo(c).\n\tcargo(d).\n\tcargo(e).\n\t&lt;/pre&gt;\n\t&lt;p&gt;Then we define the available actions of move, unload and load the rocket.\n\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\tSo move(Rocket, From, To) would look like the following.&lt;/p&gt;\n\t&lt;pre&gt;\n\t%move(Rocket, From, To).\n\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\trocket(Rocket),\n\t\tplace(From),\n\t\tplace(To),\n\t\tFrom \\= To.\n\n\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\trocket(Rocket),\n\t\tplace(To).\n\n\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\trocket(Rocket),\n\t\tplace(From).\n\n\tLet's test out the planner\n\ttest(P) :-\n\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t     [at(a, paris)], rocket,\n\t\t     P).\n\t&lt;/pre&gt;\n\t&lt;p&gt;We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.&lt;/p&gt;\n\t&lt;p&gt;The output is\n\t&lt;pre&gt;?- test(P).\n\n\tFeasible Plan found at level 4\n\t Level  4\n\tActions :\n\t[unload(rocket1,paris,a)]\n\tState   :\n\t[at(a,paris)]\n\n\n\t Level  3\n\tActions :\n\t[no_op(11),move(rocket1,london,paris)]\n\tState   :\n\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t Level  2\n\tActions :\n\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\tState   :\n\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t Level  1\n\tActions :\n\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\tState   :\n\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\tStep 1:\n\t        move(rocket1,paris,london)\n\n\tStep 2:\n\t        load(rocket1,london,a)\n\n\tStep 3:\n\t        move(rocket1,london,paris)\n\n\tStep 4:\n\t        unload(rocket1,paris,a)\n\n\n\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t&lt;/pre&gt;&lt;/p&gt;\n\n&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G122947)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</pre>\n\n\t\t<pre>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\t</pre>\n\n\t\t<pre>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\n\t\t\tfail.\n\n\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\n\t\t\tfail.\n\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\n\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\n\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G122947)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</pre>\n\n<pre>\n<code>\t&lt;pre&gt;\n\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t&lt;/pre&gt;\n\n\t&lt;pre&gt;\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/pre&gt;&lt;/p&gt;\n\t&lt;p&gt;All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.&lt;/p&gt;\n\t&lt;p&gt;Adding the initial conditions stores the initialstate as nodes in the database. &lt;/p&gt;\n\t&lt;pre&gt;\n\tadd_initial_conditions([]).\n\tadd_initial_conditions([Pred|Conditions]):-\n\t\tadd_plan_graph(0, add, Pred, start),\n\t\tadd_initial_conditions(Conditions).&lt;/pre&gt;\n\t&lt;p&gt;We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. &lt;/p&gt;\n\t&lt;p&gt;Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. &lt;/p&gt;\n\t&lt;pre&gt;\n\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\tN1 is N-1,\n\t\t%% Check if FinalState Conditions have been satisfied \n\t        %%    and no mutual exclusion conditions have been violated\n\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t!.\n\n\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t% Add no-ops\n\t\tadd_no_op_nodes(N),\n\n\t\tfail.\n\n\n\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\tcan(Action, PreConditions, Domain),\n\t\tNPrev is N-1,\n\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\n\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(DelPreConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t    )\n\t\t),\n\n\t\t\n\t\tadds(Action, AddConditions, _, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(AddConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t    )\n\t\t),\n\n\n\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t%\tnl, write(\"Added Action: \"), write(Action),\n\t%\tnl,\n\n\t\tfail.\n\n\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t% Propagate mutual exclusions\n\t\tmutex(N),\n\n\t\tN1 is N+1,\n\t\t!,\n\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t!.\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;pre&gt;\n\tPrevActions, Plan):-\n\t\tN &gt; 0,\n\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\n\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\tlist_to_set(PreConds, MidState),\n\n\t\tnl, write(' Level  '), write(N),\n\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\tN1 is N-1,\n\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.&lt;/p&gt;\n\t&lt;p&gt;The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.&lt;/p&gt;\n\t&lt;p&gt;There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.&lt;/p&gt;\n\t&lt;p&gt;Finally, we can write the plan out to the screen by write_plan/1. &lt;/p&gt;\n\t&lt;hr&gt;\n\t&lt;p&gt;We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\tThe rocket_graph contains the defintion of domain and the available actions.\n\tThis example wants to move the cargos from one city to another.\n\tWe first define the knowledge base of rocket, place and cargo.&lt;/p&gt;\n\t&lt;pre&gt;\n\tplace(london).\n\tplace(paris).\n\tcargo(a).\n\tcargo(b).\n\tcargo(c).\n\tcargo(d).\n\tcargo(e).\n\t&lt;/pre&gt;\n\t&lt;p&gt;Then we define the available actions of move, unload and load the rocket.\n\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\tSo move(Rocket, From, To) would look like the following.&lt;/p&gt;\n\t&lt;pre&gt;\n\t%move(Rocket, From, To).\n\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\trocket(Rocket),\n\t\tplace(From),\n\t\tplace(To),\n\t\tFrom \\= To.\n\n\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\trocket(Rocket),\n\t\tplace(To).\n\n\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\trocket(Rocket),\n\t\tplace(From).\n\n\tLet's test out the planner\n\ttest(P) :-\n\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t     [at(a, paris)], rocket,\n\t\t     P).\n\t&lt;/pre&gt;\n\t&lt;p&gt;We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.&lt;/p&gt;\n\t&lt;p&gt;The output is\n\t&lt;pre&gt;?- test(P).\n\n\tFeasible Plan found at level 4\n\t Level  4\n\tActions :\n\t[unload(rocket1,paris,a)]\n\tState   :\n\t[at(a,paris)]\n\n\n\t Level  3\n\tActions :\n\t[no_op(11),move(rocket1,london,paris)]\n\tState   :\n\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t Level  2\n\tActions :\n\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\tState   :\n\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t Level  1\n\tActions :\n\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\tState   :\n\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\tStep 1:\n\t        move(rocket1,paris,london)\n\n\tStep 2:\n\t        load(rocket1,london,a)\n\n\tStep 3:\n\t        move(rocket1,london,paris)\n\n\tStep 4:\n\t        unload(rocket1,paris,a)\n\n\n\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t&lt;/pre&gt;&lt;/p&gt;\n\n&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G70656)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G70656)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G53072)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G53072)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G72419)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,_G72419)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1422921600)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G72419)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
assertz(col(entry,'481be28c-48ab-42b8-a724-bb8b105ff4db')).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',commenting,true)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,"<h2>What is a Prolog Planner?</h2>\n\n------------------------- \n\n<p>This page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p>\n\n<p>A prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.</p>  \n\n<p>Planners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p>\n\n<p>They differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.   </p> \n  \n<h3>Consider the following example problem:</h3>\n\n>A hungry monkey is in a room. Suspended from the roof,<br> \n>just out of his reach, is a bunch of bananas. <br>\n>In the corner of the\n>room is a box. The monkey desperately wants the bananas\n>but he cant reach them. <br>What shall he do?<br>\n>After several unsuccessful attempts to reach the bananas, the\n>monkey walks to the box,<br> pushes it under the bananas, climbs\n>on the box, picks the bananas and eats them.<br>\n>The hungry monkey is now a happy monkey.\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b>\n\n<br>\n<br>\n\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.\n\n* Actions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n* However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n* A good planning representation should therefore take into account\nthis locality of the effects of actions.\n\n<br>\n<br>\n\n\n*We need to define a representation for two things:*\n\n - How will we represent the state of the world?\n\n - How will we represent actions and their local effect on the world?\n\n<br>\n<br>\n\nActions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n - However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n - A good planning representation should therefore take into\naccount this locality of the effects of actions.\n\n\n<br>\n<br>\n\n*Therefore, we need to be able to represent three states of the world:*\n\n\n- initial state\n\n- current state\n\n- goal state\n\n\n<br>\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n<br>\n\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.\n\n\n<br>\n<br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content_type,markdown)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',date_updated,1423267200)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',description,"")).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,"<h2>What is a Prolog Planner?</h2>\n<hr>\n<p>This page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p><p>A prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.</p>  <p>Planners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p><p>They differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.   </p> \n  \n<h3>Consider the following example problem:</h3>\n\n<blockquote>\nA hungry monkey is in a room. Suspended from the roof,<br> \njust out of his reach, is a bunch of bananas. <br>\nIn the corner of the\nroom is a box. The monkey desperately wants the bananas\nbut he cant reach them. <br>What shall he do?<br>\nAfter several unsuccessful attempts to reach the bananas, the\nmonkey walks to the box,<br> pushes it under the bananas, climbs\non the box, picks the bananas and eats them.<br>\nThe hungry monkey is now a happy monkey.\n</blockquote>\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b><br>\n<br>\n\n<p>\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.</p>\n<ul>\n<li>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p></li>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into account\nthis locality of the effects of actions.</p></li>\n</ul>\n<br>\n<br>\n\n<p>\n<em>We need to define a representation for two things:</em></p>\n<ul>\n<li>\n\n<p>\nHow will we represent the state of the world?</p></li>\n<li>\n\n<p>\nHow will we represent actions and their local effect on the world?</p></li>\n</ul>\n<br>\n<br>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p>\n<ul>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into\naccount this locality of the effects of actions.</p></li>\n</ul>\n<br>\n<br>\n\n<p>\n<em>Therefore, we need to be able to represent three states of the world:</em></p>\n<ul>\n<li>\n\n<p>\ninitial state</p></li>\n<li>\n\n<p>\ncurrent state</p></li>\n<li>\n\n<p>\ngoal state</p></li>\n</ul>\n<br>\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n<br>\n\n<p>\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.</p><br>\n<br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',language,"en")).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',published,false)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',slug,'introduction-to-prolog-planning')).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',tags,[])).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',title,"Introduction to Prolog Planning")).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',type,page)).
end.
begin.
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',slug,_G31019)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',slug,intro)).
end.
begin.
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,_G6670)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,"<h2>What is a Prolog Planner?</h2>\n\n------------------------- \n\n<p>This page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p>\n\n<p>A prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.</p>  \n\n<p>Planners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p>\n\n<p>They differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.   </p> \n  \n<h3>Consider the following example problem:</h3>\n\n>A hungry monkey is in a room. Suspended from the roof,<br> \n>just out of his reach, is a bunch of bananas. <br>\n>In the corner of the\n>room is a box. The monkey desperately wants the bananas\n>but he cant reach them. <br>What shall he do?<br>\n>After several unsuccessful attempts to reach the bananas, the\n>monkey walks to the box,<br> pushes it under the bananas, climbs\n>on the box, picks the bananas and eats them.<br>\n>The hungry monkey is now a happy monkey.\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b>\n\n<br>\n\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.\n\n* Actions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n* However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n* A good planning representation should therefore take into account\nthis locality of the effects of actions.\n\n<br>\n\n\n*We need to define a representation for two things:*\n\n - How will we represent the state of the world?\n\n - How will we represent actions and their local effect on the world?\n\n<br>\n\nActions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n - However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n - A good planning representation should therefore take into\naccount this locality of the effects of actions.\n\n\n<br>\n\n*Therefore, we need to be able to represent three states of the world:*\n\n\n- initial state\n\n- current state\n\n- goal state\n\n\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.\n\n\n<br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,_G6670)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,"<h2>What is a Prolog Planner?</h2>\n<hr>\n<p>This page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p><p>A prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.</p>  <p>Planners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p><p>They differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.   </p> \n  \n<h3>Consider the following example problem:</h3>\n\n<blockquote>\nA hungry monkey is in a room. Suspended from the roof,<br> \njust out of his reach, is a bunch of bananas. <br>\nIn the corner of the\nroom is a box. The monkey desperately wants the bananas\nbut he cant reach them. <br>What shall he do?<br>\nAfter several unsuccessful attempts to reach the bananas, the\nmonkey walks to the box,<br> pushes it under the bananas, climbs\non the box, picks the bananas and eats them.<br>\nThe hungry monkey is now a happy monkey.\n</blockquote>\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b><br>\n\n<p>\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.</p>\n<ul>\n<li>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p></li>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into account\nthis locality of the effects of actions.</p></li>\n</ul>\n<br>\n\n<p>\n<em>We need to define a representation for two things:</em></p>\n<ul>\n<li>\n\n<p>\nHow will we represent the state of the world?</p></li>\n<li>\n\n<p>\nHow will we represent actions and their local effect on the world?</p></li>\n</ul>\n<br>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p>\n<ul>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into\naccount this locality of the effects of actions.</p></li>\n</ul>\n<br>\n\n<p>\n<em>Therefore, we need to be able to represent three states of the world:</em></p>\n<ul>\n<li>\n\n<p>\ninitial state</p></li>\n<li>\n\n<p>\ncurrent state</p></li>\n<li>\n\n<p>\ngoal state</p></li>\n</ul>\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n\n<p>\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.</p><br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
end.
begin.
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,_G5129)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,"<h2>What is a Prolog Planner?</h2>\n\n------------------------- \n\n<p>This page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p>\n\n<p>A prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.</p>  \n\n<p>Planners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p>\n\n<p>They differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.   </p> \n  \n<h3>Consider the following example problem:</h3>\n\n>A hungry monkey is in a room. Suspended from the roof,<br> \n>just out of his reach, is a bunch of bananas. <br>\n>In the corner of the\n>room is a box. The monkey desperately wants the bananas\n>but he cant reach them. <br>What shall he do?<br>\n>After several unsuccessful attempts to reach the bananas, the\n>monkey walks to the box,<br> pushes it under the bananas, climbs\n>on the box, picks the bananas and eats them.<br>\n>The hungry monkey is now a happy monkey.\n<br>\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b>\n\n<br>\n\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.\n\n* Actions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n* However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n* A good planning representation should therefore take into account\nthis locality of the effects of actions.\n\n<br>\n\n\n*We need to define a representation for two things:*\n\n - How will we represent the state of the world?\n\n - How will we represent actions and their local effect on the world?\n\n<br>\n\nActions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n - However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n - A good planning representation should therefore take into\naccount this locality of the effects of actions.\n\n\n<br>\n\n*Therefore, we need to be able to represent three states of the world:*\n\n\n- initial state\n\n- current state\n\n- goal state\n\n\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.\n\n\n<br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,_G5129)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,"<h2>What is a Prolog Planner?</h2>\n<hr>\n<p>This page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p><p>A prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.</p>  <p>Planners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p><p>They differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.   </p> \n  \n<h3>Consider the following example problem:</h3>\n\n<blockquote>\n\n<p>\nA hungry monkey is in a room. Suspended from the roof,<br> \njust out of his reach, is a bunch of bananas. <br>\nIn the corner of the\nroom is a box. The monkey desperately wants the bananas\nbut he cant reach them. <br>What shall he do?<br>\nAfter several unsuccessful attempts to reach the bananas, the\nmonkey walks to the box,<br> pushes it under the bananas, climbs\non the box, picks the bananas and eats them.<br>\nThe hungry monkey is now a happy monkey.</p><br>\n</blockquote>\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b><br>\n\n<p>\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.</p>\n<ul>\n<li>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p></li>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into account\nthis locality of the effects of actions.</p></li>\n</ul>\n<br>\n\n<p>\n<em>We need to define a representation for two things:</em></p>\n<ul>\n<li>\n\n<p>\nHow will we represent the state of the world?</p></li>\n<li>\n\n<p>\nHow will we represent actions and their local effect on the world?</p></li>\n</ul>\n<br>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p>\n<ul>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into\naccount this locality of the effects of actions.</p></li>\n</ul>\n<br>\n\n<p>\n<em>Therefore, we need to be able to represent three states of the world:</em></p>\n<ul>\n<li>\n\n<p>\ninitial state</p></li>\n<li>\n\n<p>\ncurrent state</p></li>\n<li>\n\n<p>\ngoal state</p></li>\n</ul>\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n\n<p>\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.</p><br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
end.
begin.
retractall(eav('d67f244f-c861-41d6-a9bc-21b10630148f',files,_G26829)).
retractall(eav('d9556236-364e-4796-a7e8-3337e82660f3',files,_G26829)).
assertz(col(migration,'d4002551-7691-4a20-a8a2-fa15e5294bfc')).
assertz(eav('d4002551-7691-4a20-a8a2-fa15e5294bfc',description,'Removes files key from users')).
assertz(eav('d4002551-7691-4a20-a8a2-fa15e5294bfc',name,bc_remove_files)).
end.
begin.
assertz(col(entry,'b192553d-e67b-4c73-a786-9ca3609b441d')).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',commenting,true)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>")).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content_type,markdown)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',date_published,1423353600)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',date_updated,1423353600)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',description,"")).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br>")).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',language,"en")).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',published,false)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',slug,types)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',tags,[])).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',title,"Types of Planners")).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',type,page)).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',slug,_G9033)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',slug,type)).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,_G2912)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>\n\n<h3> Hierarchical Network Planners </h3>\n\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\nIn HTN, tasks are broken into 3 categories:\n\n* Primitive tasks, which roughly correspond to actions of STRIPS\n* Compound tasks, which can be seen as composed of a set of simpler tasks\n* goal tasks, which roughly correspond to the goals of STRIPS, but are more general\n\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p>\n\n<p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p>\n\n<p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p>\n\n<br>\n\n<h4> Planning Domain Definition Language </h4>\n\n---------------------------------------------\n\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n\n* Objects- Things in the world that interest us\n* Predicates- Properties of objects that we are interested in; can be true or false\n* Initial State- The state of the world that we start in\n* Goal specification- Things that we want to be true\n* Actions/Operators- Ways of changing the state of the world\n\nIn PDDL, planning tasks are separated into 2 files\n\n* A domain file for predicates and actions\n* A problem file for objects, initial state and goal specification\n\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p>\n\n<p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p>\n\n<p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p>\n\n<b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b>\n\n<h4> Narrative Generation </h4>\n\n-------------------------------\n\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p>\n\n<p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p>\n\n<p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,_G2912)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br><h3> Hierarchical Network Planners </h3><p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\n<p>\nIn HTN, tasks are broken into 3 categories:</p>\n<ul>\n<li>Primitive tasks, which roughly correspond to actions of STRIPS</li>\n<li>Compound tasks, which can be seen as composed of a set of simpler tasks</li>\n<li>goal tasks, which roughly correspond to the goals of STRIPS, but are more general</li>\n</ul>\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p><p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p><p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p><br><h4> Planning Domain Definition Language </h4>\n<hr>\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n<ul>\n<li>Objects- Things in the world that interest us</li>\n<li>Predicates- Properties of objects that we are interested in; can be true or false</li>\n<li>Initial State- The state of the world that we start in</li>\n<li>Goal specification- Things that we want to be true</li>\n<li>Actions/Operators- Ways of changing the state of the world</li>\n</ul>\n\n<p>\nIn PDDL, planning tasks are separated into 2 files</p>\n<ul>\n<li>A domain file for predicates and actions</li>\n<li>A problem file for objects, initial state and goal specification</li>\n</ul>\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p><p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p><p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p><b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b><h4> Narrative Generation </h4>\n<hr>\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p><p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p><p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,_G6210)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>\n\n<h3> Hierarchical Network Planners </h3>\n\n---------------\n\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\nIn HTN, tasks are broken into 3 categories:\n\n* Primitive tasks, which roughly correspond to actions of STRIPS\n* Compound tasks, which can be seen as composed of a set of simpler tasks\n* goal tasks, which roughly correspond to the goals of STRIPS, but are more general\n\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p>\n\n<p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p>\n\n<p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p>\n\n<br>\n\n<h4> Planning Domain Definition Language </h4>\n\n---------------------------------------------\n\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n\n* Objects- Things in the world that interest us\n* Predicates- Properties of objects that we are interested in; can be true or false\n* Initial State- The state of the world that we start in\n* Goal specification- Things that we want to be true\n* Actions/Operators- Ways of changing the state of the world\n\nIn PDDL, planning tasks are separated into 2 files\n\n* A domain file for predicates and actions\n* A problem file for objects, initial state and goal specification\n\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p>\n\n<p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p>\n\n<p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p>\n\n<b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b>\n\n<h4> Narrative Generation </h4>\n\n-------------------------------\n\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p>\n\n<p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p>\n\n<p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,_G6210)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br><h3> Hierarchical Network Planners </h3>\n<hr>\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\n<p>\nIn HTN, tasks are broken into 3 categories:</p>\n<ul>\n<li>Primitive tasks, which roughly correspond to actions of STRIPS</li>\n<li>Compound tasks, which can be seen as composed of a set of simpler tasks</li>\n<li>goal tasks, which roughly correspond to the goals of STRIPS, but are more general</li>\n</ul>\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p><p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p><p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p><br><h4> Planning Domain Definition Language </h4>\n<hr>\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n<ul>\n<li>Objects- Things in the world that interest us</li>\n<li>Predicates- Properties of objects that we are interested in; can be true or false</li>\n<li>Initial State- The state of the world that we start in</li>\n<li>Goal specification- Things that we want to be true</li>\n<li>Actions/Operators- Ways of changing the state of the world</li>\n</ul>\n\n<p>\nIn PDDL, planning tasks are separated into 2 files</p>\n<ul>\n<li>A domain file for predicates and actions</li>\n<li>A problem file for objects, initial state and goal specification</li>\n</ul>\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p><p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p><p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p><b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b><h4> Narrative Generation </h4>\n<hr>\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p><p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p><p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,_G6215)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>\n<br>\n\n<h3> Hierarchical Network Planners </h3>\n\n---------------\n\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\nIn HTN, tasks are broken into 3 categories:\n\n* Primitive tasks, which roughly correspond to actions of STRIPS\n* Compound tasks, which can be seen as composed of a set of simpler tasks\n* goal tasks, which roughly correspond to the goals of STRIPS, but are more general\n\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p>\n\n<p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p>\n\n<p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p>\n\n<br>\n\n<h4> Planning Domain Definition Language </h4>\n\n---------------------------------------------\n\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n\n* Objects- Things in the world that interest us\n* Predicates- Properties of objects that we are interested in; can be true or false\n* Initial State- The state of the world that we start in\n* Goal specification- Things that we want to be true\n* Actions/Operators- Ways of changing the state of the world\n\nIn PDDL, planning tasks are separated into 2 files\n\n* A domain file for predicates and actions\n* A problem file for objects, initial state and goal specification\n\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p>\n\n<p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p>\n\n<p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p>\n\n<b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b>\n\n<h4> Narrative Generation </h4>\n\n-------------------------------\n\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p>\n\n<p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p>\n\n<p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,_G6215)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br>\n<br><h3> Hierarchical Network Planners </h3>\n<hr>\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\n<p>\nIn HTN, tasks are broken into 3 categories:</p>\n<ul>\n<li>Primitive tasks, which roughly correspond to actions of STRIPS</li>\n<li>Compound tasks, which can be seen as composed of a set of simpler tasks</li>\n<li>goal tasks, which roughly correspond to the goals of STRIPS, but are more general</li>\n</ul>\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p><p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p><p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p><br><h4> Planning Domain Definition Language </h4>\n<hr>\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n<ul>\n<li>Objects- Things in the world that interest us</li>\n<li>Predicates- Properties of objects that we are interested in; can be true or false</li>\n<li>Initial State- The state of the world that we start in</li>\n<li>Goal specification- Things that we want to be true</li>\n<li>Actions/Operators- Ways of changing the state of the world</li>\n</ul>\n\n<p>\nIn PDDL, planning tasks are separated into 2 files</p>\n<ul>\n<li>A domain file for predicates and actions</li>\n<li>A problem file for objects, initial state and goal specification</li>\n</ul>\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p><p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p><p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p><b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b><h4> Narrative Generation </h4>\n<hr>\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p><p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p><p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,_G6216)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>\n<br>\n\n<h3> Hierarchical Network Planners </h3>\n\n---------------\n\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\nIn HTN, tasks are broken into 3 categories:\n\n* Primitive tasks, which roughly correspond to actions of STRIPS\n* Compound tasks, which can be seen as composed of a set of simpler tasks\n* goal tasks, which roughly correspond to the goals of STRIPS, but are more general\n\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p>\n\n<p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p>\n\n<p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p>\n\n<br>\n\n<h3> Planning Domain Definition Language </h3>\n\n---------------------------------------------\n\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n\n* Objects- Things in the world that interest us\n* Predicates- Properties of objects that we are interested in; can be true or false\n* Initial State- The state of the world that we start in\n* Goal specification- Things that we want to be true\n* Actions/Operators- Ways of changing the state of the world\n\nIn PDDL, planning tasks are separated into 2 files\n\n* A domain file for predicates and actions\n* A problem file for objects, initial state and goal specification\n\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p>\n\n<p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p>\n\n<p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p>\n\n<b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b>\n\n<h3> Narrative Generation </h3>\n\n-------------------------------\n\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p>\n\n<p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p>\n\n<p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,_G6216)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br>\n<br><h3> Hierarchical Network Planners </h3>\n<hr>\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\n<p>\nIn HTN, tasks are broken into 3 categories:</p>\n<ul>\n<li>Primitive tasks, which roughly correspond to actions of STRIPS</li>\n<li>Compound tasks, which can be seen as composed of a set of simpler tasks</li>\n<li>goal tasks, which roughly correspond to the goals of STRIPS, but are more general</li>\n</ul>\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p><p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p><p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p><br><h3> Planning Domain Definition Language </h3>\n<hr>\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n<ul>\n<li>Objects- Things in the world that interest us</li>\n<li>Predicates- Properties of objects that we are interested in; can be true or false</li>\n<li>Initial State- The state of the world that we start in</li>\n<li>Goal specification- Things that we want to be true</li>\n<li>Actions/Operators- Ways of changing the state of the world</li>\n</ul>\n\n<p>\nIn PDDL, planning tasks are separated into 2 files</p>\n<ul>\n<li>A domain file for predicates and actions</li>\n<li>A problem file for objects, initial state and goal specification</li>\n</ul>\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p><p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p><p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p><b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b><h3> Narrative Generation </h3>\n<hr>\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p><p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p><p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,_G21778)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>\n<br>\n\n<h3> Hierarchical Network Planners </h3>\n\n---------------\n\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\nIn HTN, tasks are broken into 3 categories:\n\n* Primitive tasks, which roughly correspond to actions of STRIPS\n* Compound tasks, which can be seen as composed of a set of simpler tasks\n* goal tasks, which roughly correspond to the goals of STRIPS, but are more general\n\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p>\n\n<p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p>\n\n<p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p>\n\n<br>\n\n<h3> Planning Domain Definition Language </h3>\n\n---------------------------------------------\n\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n\n* Objects- Things in the world that interest us\n* Predicates- Properties of objects that we are interested in; can be true or false\n* Initial State- The state of the world that we start in\n* Goal specification- Things that we want to be true\n* Actions/Operators- Ways of changing the state of the world\n\nIn PDDL, planning tasks are separated into 2 files\n\n* A domain file for predicates and actions\n* A problem file for objects, initial state and goal specification\n\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p>\n\n<p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p>\n\n<p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p>\n\n<b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b>\n\n<br>\n\n<h3> Narrative Generation </h3>\n\n-------------------------------\n\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p>\n\n<p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p>\n\n<p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,_G21778)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br>\n<br><h3> Hierarchical Network Planners </h3>\n<hr>\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\n<p>\nIn HTN, tasks are broken into 3 categories:</p>\n<ul>\n<li>Primitive tasks, which roughly correspond to actions of STRIPS</li>\n<li>Compound tasks, which can be seen as composed of a set of simpler tasks</li>\n<li>goal tasks, which roughly correspond to the goals of STRIPS, but are more general</li>\n</ul>\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p><p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p><p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p><br><h3> Planning Domain Definition Language </h3>\n<hr>\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n<ul>\n<li>Objects- Things in the world that interest us</li>\n<li>Predicates- Properties of objects that we are interested in; can be true or false</li>\n<li>Initial State- The state of the world that we start in</li>\n<li>Goal specification- Things that we want to be true</li>\n<li>Actions/Operators- Ways of changing the state of the world</li>\n</ul>\n\n<p>\nIn PDDL, planning tasks are separated into 2 files</p>\n<ul>\n<li>A domain file for predicates and actions</li>\n<li>A problem file for objects, initial state and goal specification</li>\n</ul>\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p><p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p><p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p><b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b><br><h3> Narrative Generation </h3>\n<hr>\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p><p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p><p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
end.
begin.
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,_G6227)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',content,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    \n\n<h3>STRIPS Planning</h3>\n\n---------------\n\n\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n\n* Initial state\n* Specification of goal states-situation where the planner is trying to reach\n* Set of actions which include a precondition and postcondition\n\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p>\n\n<p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p>\n\n<p> Actions in STRIPS are represented in 3 phases.\n\n* PRE of preconditions of facts\n* ADD of add effects facts\n* DEL of delete effect facts\n\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p>\n\n<p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p>\n\n<b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b>\n\n<br>\n<br>\n\n<h3> Hierarchical Network Planners </h3>\n\n---------------\n\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\nIn HTN, tasks are broken into 3 categories:\n\n* Primitive tasks, which roughly correspond to actions of STRIPS\n* Compound tasks, which can be seen as composed of a set of simpler tasks\n* goal tasks, which roughly correspond to the goals of STRIPS, but are more general\n\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p>\n\n<p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p>\n\n<p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p>\n\n<br>\n\n<h3> Planning Domain Definition Language </h3>\n\n---------------------------------------------\n\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n\n* Objects- Things in the world that interest us\n* Predicates- Properties of objects that we are interested in; can be true or false\n* Initial State- The state of the world that we start in\n* Goal specification- Things that we want to be true\n* Actions/Operators- Ways of changing the state of the world\n\nIn PDDL, planning tasks are separated into 2 files\n\n* A domain file for predicates and actions\n* A problem file for objects, initial state and goal specification\n\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p>\n\n<p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p>\n\n<p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p>\n\n<b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b>\n\n<br>\n<br>\n\n<h3> Narrative Generation </h3>\n\n-------------------------------\n\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p>\n\n<p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p>\n\n<p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
retractall(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,_G6227)).
assertz(eav('b192553d-e67b-4c73-a786-9ca3609b441d',html,"<p>There are many applications of planners that are being used in the world today. Examples use of planners range from space missions, medical diagnosis, vacation planners, project management and  artificial intelligence. There are different kind of planners, each with their own strengths and characteristics.</p>    <h3>STRIPS Planning</h3>\n<hr>\n<p>STRIPS, also known as Stanford Research Institute Problem Solver, is one of the most used automated planners. <br>Most planners incorporate some style of STRIPS into their planning scheme. A STRIPS planner instance is composed of 3 major components:</p>\n<ul>\n<li>Initial state</li>\n<li>Specification of goal states-situation where the planner is trying to reach</li>\n<li>Set of actions which include a precondition and postcondition</li>\n</ul>\n<p> In strips, the initial state, is the starting initial set of conditions that are all true. In order to reach the goal state, there are world states that are represented as a set of facts. World states can be thought as options for the planner to take to reach the goal. In STRIPS, the closed world assumption states that any fact not listed in a state is assumed to be false<p><p> Goals are also represented as a set of facts. The goal state is any state that contains all the goal facts for the condition to be met.</p><p> Actions in STRIPS are represented in 3 phases.\n<ul>\n<li>PRE of preconditions of facts</li>\n<li>ADD of add effects facts</li>\n<li>DEL of delete effect facts</li>\n</ul>\n\n<p>\nAn action is only allowed in a new state when the preconditions are contained in the old state. Once the action has been executed, the planner enters a new state with a given set of new facts. From there , the planner either checks if it has reached its goal state, or repeats and continues on to reach the goal state.</p></p><p> In short, the objective of a STRIPS planner is to find a short action sequence reaching a goal state, or report that the goal is unachievable.</p><b>Credit to <a href=\"http://en.wikipedia.org/wiki/STRIPS\">Wikipedia</a> and <a href=\"http://web.engr.oregonstate.edu/~afern/classes/cs533/notes/strips-intro.pdf\"> Alan Fern</a> of Oregon State for information</b><br>\n<br><h3> Hierarchical Network Planners </h3>\n<hr>\n<p> HTN are another type of planners used in automated planning. Similar to strips, HTN differ from STRIPS in which dependency among actions can be given in the form of networks\n\n<p>\nIn HTN, tasks are broken into 3 categories:</p>\n<ul>\n<li>Primitive tasks, which roughly correspond to actions of STRIPS</li>\n<li>Compound tasks, which can be seen as composed of a set of simpler tasks</li>\n<li>goal tasks, which roughly correspond to the goals of STRIPS, but are more general</li>\n</ul>\n<p> A primitive task by definition is an action that can be executed, a compound task is a complex task composed of a sequence of actions,<br> and a goal task is the task of satisfying a condition. <br>Primitive actions can be executed directly while compound and goal tasks require a sequence of primitive actions to be formed. <br>Goal tasks however are specified in terms of conditions that to be made true,<br> while compound tasks can only be specified in terms of other tasks through the task network. </p><p> Constraints among tasks are expressed in form of networks called task networks. A task network is a set of tasks and constraints among them,<br> and can be used as a precondition for another compound task or goal to be attainable. <br>With this setup, one can express a given task is doable only if a set of other actions within the network are done,<br> and done with such a way that the constraints are satisfied. </p><p>An example would be that a condition is necessary for a specific primitive action to be executed.<br> When this is used as the precondition for a compound task or goal, it means that the compound or goal task requires the primitive action to be executed,<br> and that the condition must be true for its execution to successfully achieve the compound or goal task.</p><br><h3> Planning Domain Definition Language </h3>\n<hr>\n<p> The PDDL was a attempt to be the standard for classical programming tasks. PDDL is composed of the following components:\n<ul>\n<li>Objects- Things in the world that interest us</li>\n<li>Predicates- Properties of objects that we are interested in; can be true or false</li>\n<li>Initial State- The state of the world that we start in</li>\n<li>Goal specification- Things that we want to be true</li>\n<li>Actions/Operators- Ways of changing the state of the world</li>\n</ul>\n\n<p>\nIn PDDL, planning tasks are separated into 2 files</p>\n<ul>\n<li>A domain file for predicates and actions</li>\n<li>A problem file for objects, initial state and goal specification</li>\n</ul>\n<p>In the Domain file, the title of the file specifies the domain name, followed by the Objects and the predicates. After this are the list of actions with parameters, with preconditions and effects, similar to STRIPS. The effects of actions could also be conditional</p><p>In the problem file, the title of the file specifies the problem name. Followed by the problem name is the domain name, which must match the corresponding domain with the corresponding domain file. The file then specifies the initial state, followed by the goal specification.</p><p> As described above, PDDL is very similar to STRIPS with the preconditions, effects, initial state and goal state. The only major difference is that the problem is separated into a different file. Nevertheless, PDDL is a excellent planner to use when deciding to choose a planner.</p><b> Credit to Malte Helmert of <a href=\"http://www.cs.toronto.edu/~sheila/2542/s14/A1/introtopddl2.pdf\">University of Toronto</a> and <a href= \"http://en.wikipedia.org/wiki/Planning_Domain_Definition_Language\">Wikipedia</a> for sources and information</b><br>\n<br><h3> Narrative Generation </h3>\n<hr>\n<p>Narrative generation is interesting type of planning, in which the made plan simulates deviations as the plan is executed. The planner replans based on the new state, and continues on its way to its goal. Sometimes, the end goal is changed in order make the specific goal achievable.</p><p>For example, a plane takes off from a certain airport, all is going well after take off until a passenger gets extremely sick. The planner simulates the sick passenger deviation, as a regular trip would just end with nothing significantly happening. From there, the planner can decide  to change the end destination, continue on to the designated end designation, or fly back to the starting airport. The narrative generator has many options as this point, and can simulate the different goal endings at well!</p><p>You can check out a great example called <a href=\"https://github.com/Anniepoo/prolog-examples/blob/master/talespin2.pl\">Talespin</a> written by Anne Ogborn, a active prolog user in the prolog community. The only requirement is to have prolog installed on your system, and once that is set up, simply run the file and the planner will run different deviations of the journey!</p>")).
end.
begin.
assertz(col(entry,'8a2d92bd-ba2e-4554-a024-4d912ee9ed25')).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',commenting,true)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t\n\t</body>\n</html>")).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content_type,markdown)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',date_published,1423699200)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',date_updated,1423699200)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',description,"")).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t\n\t</body>\n</html>")).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',language,"en")).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',published,false)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',slug,problem)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',tags,[])).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',title,"Monkey and Banana Problem")).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',type,page)).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G71660)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n<p>Complete source code can be found <a href=\"https://github.com/Mortimerp9/Prolog-Graphplan\">here</a> on Github.</p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_published,1423699200)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,_G71660)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1423699200)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G71660)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n<p>Complete source code can be found <a href=\"https://github.com/Mortimerp9/Prolog-Graphplan\">here</a> on Github.</p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',published,_G71660)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',published,true)).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G23222)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial:</p>\n\t<p><code>\n\t%Initial State:\n\t% on(monkey, floor),\n\t% on(box, floor),\n\t% at(monkey, a),\n\t% at(box, b),\n\t% at(bananas, c),\n\t% status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p><code>\n\t%Goal State:\n\t% on(monkey, box),\n\t% on(box, floor),\n\t% at(monkey, c),\n\t% at(box, c),\n\t% at(bananas, c),\n\t% status(bananas, grabbed).\n\t</code></p>\n\t\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G23222)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial:</p>\n\t<p><code>\n\t%Initial State:\n\t% on(monkey, floor),\n\t% on(box, floor),\n\t% at(monkey, a),\n\t% at(box, b),\n\t% at(bananas, c),\n\t% status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p><code>\n\t%Goal State:\n\t% on(monkey, box),\n\t% on(box, floor),\n\t% at(monkey, c),\n\t% at(box, c),\n\t% at(bananas, c),\n\t% status(bananas, grabbed).\n\t</code></p>\n\t\n\t</body>\n</html>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G24399)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p><code>\n\tInitial State:<br>\n\t on(monkey, floor),<br>\n\t on(box, floor),<br>\n\t at(monkey, a),<br>\n\t at(box, b),<br>\n\t at(bananas, c),<br>\n\t status(bananas, hanging).<br>\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p><code>\n\tGoal State:<br>\n\t on(monkey, box),<br>\n\t on(box, floor),<br>\n\t at(monkey, c),<br>\n\t at(box, c),<br>\n\t at(bananas, c),<br>\n\t status(bananas, grabbed).<br>\n\t</code></p>\n\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G24399)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p><code>\n\tInitial State:<br>\n\t on(monkey, floor),<br>\n\t on(box, floor),<br>\n\t at(monkey, a),<br>\n\t at(box, b),<br>\n\t at(bananas, c),<br>\n\t status(bananas, hanging).<br>\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p><code>\n\tGoal State:<br>\n\t on(monkey, box),<br>\n\t on(box, floor),<br>\n\t at(monkey, c),<br>\n\t at(box, c),<br>\n\t at(bananas, c),<br>\n\t status(bananas, grabbed).<br>\n\t</code></p>\n\n<pre>\n<code>&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G23616)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<code>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<code>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</code></p>\n\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G23616)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<code>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<code>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</code></p>\n\n<pre>\n<code>&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G25587)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<code>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<code>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</code></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G25587)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<code>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<code>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</code></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G14266)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<code>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<code>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</code></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><code>\n\t% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), [at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor), at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.\n\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).\n\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</code></p>\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G14266)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<code>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</code></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<code>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</code></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><code>\n\t% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), [at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor), at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.\n\n<p>\nadds(go(Monkey,<em>X,Y), [at(Monkey, Y)], </em>, monkey):-</p>\n\n<pre>\n<code>monkey(Monkey),\nlocation(Y).</code>\n</pre>\n\n<p>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-</p>\n\n<pre>\n<code>monkey(Monkey),\nlocation(X).\n&lt;/code&gt;&lt;/p&gt;\n&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G14307)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n\t% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), [at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor), at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.\n\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).\n\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',date_updated,_G14307)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',date_updated,1423785600)).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G14307)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n\t% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), [at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor), at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.\n\n<p>\nadds(go(Monkey,<em>X,Y), [at(Monkey, Y)], </em>, monkey):-</p>\n\n<pre>\n<code>monkey(Monkey),\nlocation(Y).</code>\n</pre>\n\n<p>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-</p>\n\n<pre>\n<code>monkey(Monkey),\nlocation(X).\n&lt;/pre&gt;&lt;/p&gt;\n&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G35114)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), \n[at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor),at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.<br>\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).<br>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G35114)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\n\t on(monkey, floor),\n\t on(box, floor),\n\t at(monkey, a),\n\t at(box, b),\n\t at(bananas, c),\n\t status(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\n\t on(monkey, box),\n\t on(box, floor),\n\t at(monkey, c),\n\t at(box, c),\n\t at(bananas, c),\n\t status(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), \n[at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor),at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.<br>\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).<br>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G12638)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\non(monkey, floor),\non(box, floor),\nat(monkey, a),\nat(box, b),\nat(bananas, c),\nstatus(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\non(monkey, box),\non(box, floor),\nat(monkey, c),\nat(box, c),\nat(bananas, c),\nstatus(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), \n[at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor),at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.<br>\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).<br>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G12638)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Banana Problem</h1>\n\t<hr>\n\t<p>Monkey and Banana problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\non(monkey, floor),\non(box, floor),\nat(monkey, a),\nat(box, b),\nat(bananas, c),\nstatus(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\non(monkey, box),\non(box, floor),\nat(monkey, c),\nat(box, c),\nat(bananas, c),\nstatus(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), \n[at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor),at(Bananas,Z)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tbananas(Bananas),\n\tmonkey(Monkey),\n\tbox(Box),\n\tY \\= Z,\n\tX \\= Y.<br>\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).<br>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,_G49946)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Bananas Problem</h1>\n\t<hr>\n\t<p>Monkey and Bananas Problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\non(monkey, floor),\non(box, floor),\nat(monkey, a),\nat(box, b),\nat(bananas, c),\nstatus(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\non(monkey, box),\non(box, floor),\nat(monkey, c),\nat(box, c),\nat(bananas, c),\nstatus(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), \n[at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tmonkey(Monkey),\n\tbox(Box),\n\tX \\= Y.<br>\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).<br>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t<p>The condition when a monkey can move from X to Y is when the monkey is on the floor and there is a Box at Y so that the monkey wants to move there to get to the box. Also, we want to make sure that X and Y are different.</p>\n\t<p>The add predicate adds the new state to the current states. In this case, it adds at(Monkey, Y) indicating that the monkey is at Y now. The delete predicate deletes the old state that is no longer true, which is at(Monkey, X) as the Monkey moves to Y.</p>\n\t<p>The other actions follow the similar logic</p>\n\t<p>For push/3:</p>\n\t<p><pre>\n% push(Monkey,X,Y)\ncan(push(Monkey,X,Y), [at(Monkey,X), at(Box, X), at(Bananas, Y), on(Monkey, floor), on(Box, floor)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tbananas(Bananas),\n\tbox(Box),\n\tmonkey(Monkey),\n\tX \\= Y.<br>\nadds(push(Monkey,_X,Y), [at(Monkey,Y), at(Box, Y)], _, monkey):-\n\tlocation(Y),\n\tmonkey(Monkey),\n\tbox(Box).<br>\ndeletes(push(Monkey,X,_Y), [at(Monkey,X), at(Box,X)], monkey):-\n\tlocation(X),\n\tmonkey(Monkey),\n\tbox(Box).\n\t</pre></p>\n\t<p>When using push, we need to make sure both the Monkey and the Box are at the same place so that the Monkey can push the box. After pushing, we want to delete the original location for both Monkey and Box and add the new location.</p>\n\t<br>\n\t<p>For climb_on/2:</p>\n\t<p><pre>\n% climb_on(Monkey, Box)\ncan(climb_on(Monkey,Box), [at(Monkey,X), at(Box, X), at(Bananas, X)], monkey):-\n\tlocation(X),\n\tbananas(Bananas),\n\tbox(Box),\n\tmonkey(Monkey).<br>\nadds(climb_on(Monkey,Box), [on(Monkey,Box)], _, monkey):-\n\tmonkey(Monkey),\n\tbox(Box).<br>\ndeletes(climb_on(Monkey,Box), [on(Monkey,floor)], monkey):-\n\tmonkey(Monkey),\n\tbox(Box).\n\t</pre></p>\n\t<p>When using climb_on, we need to make sure that the Monkey, the Box and the Bananas are at the same place, so that the monkey should climb on the box. We add and delete states to indicate that monkey is no longer on the floor but on the box. </p>\n\t<br>\n\t<p>For grab/2:</p>\n\t<p><pre>\n% grab(Monkey,Bananas)\ncan(grab(Monkey,Bananas), [at(Monkey,X), at(Box, X), at(Bananas, X), on(Monkey,Box)], monkey):-\n\tlocation(X),\n\tbananas(Bananas),\n\tbox(Box),\n\tmonkey(Monkey).<br>\nadds(grab(Monkey,Bananas), [status(Bananas, grabbed)], _, monkey):-\n\tmonkey(Monkey),\n\tbananas(Bananas).<br>\ndeletes(grab(Monkey,Bananas), [status(Bananas, hanging)], monkey):-\n\tmonkey(Monkey),\n\tbananas(Bananas).\n\t</pre></p>\n\t<p>When using grab, we need to make sure that the Monkey and the Box are at the same location as the Bananas. Also, the Monkey should already be on the Box. We change the status of the Bananas to grabbed from hanging.</p>\n\t<p>We know have the preconditions, the actions and the goals. It is time to run the test to find a solution for our little monkey!</p>\n\t<p><pre>\n\ttest(P):-\n\tplan([on(monkey1, floor),on(box1, floor),\n\t\tat(monkey1, a),at(box1, b),at(bananas1, c),status(bananas1, hanging)],\n\t\t[on(monkey1, box1),on(box1, floor),\n\t\tat(monkey1, c),at(box1, c),at(bananas1, c),status(bananas1, grabbed)],\n\t\tmonkey, P).\n\t</pre></p>\n\t<p>The output of P will be:</p>\n\t<p><pre>\nStep 1:\n        go(monkey1,a,b)<br>\nStep 2:\n        push(monkey1,b,c)<br>\nStep 3:\n        climb_on(monkey1,box1)<br>\nStep 4:\n        grab(monkey1,bananas1)<br>\nP = [[go(monkey1, a, b)], [push(monkey1, b, c)],\n[climb_on(monkey1, box1)], [grab(monkey1, bananas1)]] .</pre></p>\n\t<p>This is how we can solve a simple version of the Monkey and Bananas Problem. You can use this graph planner to solve a lot of different kinds of problems. The key things are to correctly define the intial states, actions and the goals. You can try doing a scheduling problem by yourself after you understand this process! Good luck and have fun learning!</p>\n\t</body>\n</html>")).
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,_G49946)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t<h1>Monkey and Bananas Problem</h1>\n\t<hr>\n\t<p>Monkey and Bananas Problem is a good example of a problem that can be solved by planner.</p>\n\t<p>We mentioned in the Introduction section the basics of Monkey and Banana problem. Now after we know about the Graphplanner, we can try use the graphplanner to solve the problem.</p>\n\t<p>First of all, we need to find out the initial condition and the goal we want to achieve.</p>\n\t<p>Following is an example of the initial state:</p>\n\t<p>\n\tInitial State:\n\t<pre>\non(monkey, floor),\non(box, floor),\nat(monkey, a),\nat(box, b),\nat(bananas, c),\nstatus(bananas, hanging).\n\t</pre></p>\n\t<p>The goal will then be:</p>\n\t<p>\n\tGoal State:\n\t<pre>\non(monkey, box),\non(box, floor),\nat(monkey, c),\nat(box, c),\nat(bananas, c),\nstatus(bananas, grabbed).\n\t</pre></p>\n\t<p>There are a few actions availble for monkey to do: go(Monkey, X, Y), push(Monkey, X, Y), climb_on(Monkey, Box), and grab(Monkey, Bananas).</p>\n\t<p>What go/3 predicate does is the action of the monkey to move from X to Y. We need to define when we can do this action and what this action adds and deletes from the states.</p>\n\t<p><pre>\n% go(Monkey,X,Y)\ncan(go(Monkey,X,Y), \n[at(Monkey, X), on(Monkey, floor), at(Box, Y), on(Box, floor)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tlocation(Z),\n\tmonkey(Monkey),\n\tbox(Box),\n\tX \\= Y.<br>\nadds(go(Monkey,_X,Y), [at(Monkey, Y)], _, monkey):-\n\tmonkey(Monkey),\n\tlocation(Y).<br>\ndeletes(go(Monkey,X,_Y), [at(Monkey, X)], monkey):-\n\tmonkey(Monkey),\n\tlocation(X).\n\t</pre></p>\n\t<p>The condition when a monkey can move from X to Y is when the monkey is on the floor and there is a Box at Y so that the monkey wants to move there to get to the box. Also, we want to make sure that X and Y are different.</p>\n\t<p>The add predicate adds the new state to the current states. In this case, it adds at(Monkey, Y) indicating that the monkey is at Y now. The delete predicate deletes the old state that is no longer true, which is at(Monkey, X) as the Monkey moves to Y.</p>\n\t<p>The other actions follow the similar logic</p>\n\t<p>For push/3:</p>\n\t<p><pre>\n% push(Monkey,X,Y)\ncan(push(Monkey,X,Y), [at(Monkey,X), at(Box, X), at(Bananas, Y), on(Monkey, floor), on(Box, floor)], monkey):-\n\tlocation(X),\n\tlocation(Y),\n\tbananas(Bananas),\n\tbox(Box),\n\tmonkey(Monkey),\n\tX \\= Y.<br>\nadds(push(Monkey,_X,Y), [at(Monkey,Y), at(Box, Y)], _, monkey):-\n\tlocation(Y),\n\tmonkey(Monkey),\n\tbox(Box).<br>\ndeletes(push(Monkey,X,_Y), [at(Monkey,X), at(Box,X)], monkey):-\n\tlocation(X),\n\tmonkey(Monkey),\n\tbox(Box).\n\t</pre></p>\n\t<p>When using push, we need to make sure both the Monkey and the Box are at the same place so that the Monkey can push the box. After pushing, we want to delete the original location for both Monkey and Box and add the new location.</p>\n\t<br>\n\t<p>For climb_on/2:</p>\n\t<p><pre>\n% climb_on(Monkey, Box)\ncan(climb_on(Monkey,Box), [at(Monkey,X), at(Box, X), at(Bananas, X)], monkey):-\n\tlocation(X),\n\tbananas(Bananas),\n\tbox(Box),\n\tmonkey(Monkey).<br>\nadds(climb_on(Monkey,Box), [on(Monkey,Box)], _, monkey):-\n\tmonkey(Monkey),\n\tbox(Box).<br>\ndeletes(climb_on(Monkey,Box), [on(Monkey,floor)], monkey):-\n\tmonkey(Monkey),\n\tbox(Box).\n\t</pre></p>\n\t<p>When using climb_on, we need to make sure that the Monkey, the Box and the Bananas are at the same place, so that the monkey should climb on the box. We add and delete states to indicate that monkey is no longer on the floor but on the box. </p>\n\t<br>\n\t<p>For grab/2:</p>\n\t<p><pre>\n% grab(Monkey,Bananas)\ncan(grab(Monkey,Bananas), [at(Monkey,X), at(Box, X), at(Bananas, X), on(Monkey,Box)], monkey):-\n\tlocation(X),\n\tbananas(Bananas),\n\tbox(Box),\n\tmonkey(Monkey).<br>\nadds(grab(Monkey,Bananas), [status(Bananas, grabbed)], _, monkey):-\n\tmonkey(Monkey),\n\tbananas(Bananas).<br>\ndeletes(grab(Monkey,Bananas), [status(Bananas, hanging)], monkey):-\n\tmonkey(Monkey),\n\tbananas(Bananas).\n\t</pre></p>\n\t<p>When using grab, we need to make sure that the Monkey and the Box are at the same location as the Bananas. Also, the Monkey should already be on the Box. We change the status of the Bananas to grabbed from hanging.</p>\n\t<p>We know have the preconditions, the actions and the goals. It is time to run the test to find a solution for our little monkey!</p>\n\t<p><pre>\n\ttest(P):-\n\tplan([on(monkey1, floor),on(box1, floor),\n\t\tat(monkey1, a),at(box1, b),at(bananas1, c),status(bananas1, hanging)],\n\t\t[on(monkey1, box1),on(box1, floor),\n\t\tat(monkey1, c),at(box1, c),at(bananas1, c),status(bananas1, grabbed)],\n\t\tmonkey, P).\n\t</pre></p>\n\t<p>The output of P will be:</p>\n\t<p><pre>\nStep 1:\n        go(monkey1,a,b)<br>\nStep 2:\n        push(monkey1,b,c)<br>\nStep 3:\n        climb_on(monkey1,box1)<br>\nStep 4:\n        grab(monkey1,bananas1)<br>\nP = [[go(monkey1, a, b)], [push(monkey1, b, c)],\n[climb_on(monkey1, box1)], [grab(monkey1, bananas1)]] .</pre></p>\n\t<p>This is how we can solve a simple version of the Monkey and Bananas Problem. You can use this graph planner to solve a lot of different kinds of problems. The key things are to correctly define the intial states, actions and the goals. You can try doing a scheduling problem by yourself after you understand this process! Good luck and have fun learning!</p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',title,_G50832)).
assertz(eav('8a2d92bd-ba2e-4554-a024-4d912ee9ed25',title,"Monkey and Bananas Problem")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G80027)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n<p>Complete source code can be found <a href=\"https://github.com/Mortimerp9/Prolog-Graphplan\">here</a> on Github.</p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n                <p>This is the example provided by the author of the planner. Next, let's see how we can apply the things we have known and solve a problem with the graph planner. Application: <a href=\"/pages/problem\">Monkey and Bananas Problem</a></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,_G80027)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1423785600)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G80027)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n<p>Complete source code can be found <a href=\"https://github.com/Mortimerp9/Prolog-Graphplan\">here</a> on Github.</p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n                <p>This is the example provided by the author of the planner. Next, let's see how we can apply the things we have known and solve a problem with the graph planner. Application: <a href=\"/pages/problem\">Monkey and Bananas Problem</a></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G80058)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n<p>Complete source code can be found <a href=\"https://github.com/Mortimerp9/Prolog-Graphplan\">here</a> on Github.</p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n                <p>This is the example provided by the author of the planner. Next, let's see how we can apply the things we have known and solve a problem with the graph planner. Application: <a href=\"/page/problem\">Monkey and Bananas Problem</a></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G80058)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n<p>Complete source code can be found <a href=\"https://github.com/Mortimerp9/Prolog-Graphplan\">here</a> on Github.</p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n                <p>This is the example provided by the author of the planner. Next, let's see how we can apply the things we have known and solve a problem with the graph planner. Application: <a href=\"/page/problem\">Monkey and Bananas Problem</a></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,_G19912)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',content,"Planning in SWI-Prolog\n----------------------\n\nThis page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required\n\nA prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.  \n\nPlanners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. \n\nThey differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.    \n  \n<h3>Consider the following example problem:</h3>\n\n>A hungry monkey is in a room. Suspended from the roof,<br> \n>just out of his reach, is a bunch of bananas. <br>\n>In the corner of the\n>room is a box. The monkey desperately wants the bananas\n>but he cant reach them. <br>What shall he do?<br>\n>After several unsuccessful attempts to reach the bananas, the\n>monkey walks to the box,<br> pushes it under the bananas, climbs\n>on the box, picks the bananas and eats them.<br>\n>The hungry monkey is now a happy monkey.\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b>\n\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.\n\n* Actions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n* However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n* A good planning representation should therefore take into account\nthis locality of the effects of actions.\n\n<br>\n\n\n*We need to define a representation for two things:*\n\n - How will we represent the state of the world?\n\n - How will we represent actions and their local effect on the world?\n\n<br>\n\nActions change the current state of the planning world, thereby\ncausing transitions to new states.\n\n - However an action does not normally change everything in the\ncurrent state, just some components of the state.\n\n - A good planning representation should therefore take into\naccount this locality of the effects of actions.\n\n\n<br>\n\n*Therefore, we need to be able to represent three states of the world:*\n\n\n- initial state\n\n- current state\n\n- goal state\n\n\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.\n\n\n<br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',date_published,1423872000)).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',date_updated,_G19912)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',date_updated,1423872000)).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',description,_G19912)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',description,"Tutorial on Planning and Story Generation in SWI-Prolog")).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,_G19912)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',html,"\n\n<h2>Planning in SWI-Prolog</h2>\n\n<p>\nThis page is to quickly introduce the planner aspect of Prolog.\nKnowledge of Prolog is not required</p>\n\n<p>\nA prolog planner is a sequence of actions that would allow the\nend user to reach the desired goal produced by a system.  </p>\n\n<p>\nPlanners are a subset of expert systems that apply artificial intelligence programming<br>techniques to problems that involve narrow, clearly defined subject areas. </p>\n\n<p>\nThey differ from conventional programs in which facts and rules are separated from a program's underlying control structure <br> and a program's reasoning can be explained simply to the user.    </p><h3>Consider the following example problem:</h3>\n\n<blockquote>\nA hungry monkey is in a room. Suspended from the roof,<br> \njust out of his reach, is a bunch of bananas. <br>\nIn the corner of the\nroom is a box. The monkey desperately wants the bananas\nbut he cant reach them. <br>What shall he do?<br>\nAfter several unsuccessful attempts to reach the bananas, the\nmonkey walks to the box,<br> pushes it under the bananas, climbs\non the box, picks the bananas and eats them.<br>\nThe hungry monkey is now a happy monkey.\n</blockquote>\n\n<b>To solve this problem the monkey needed to devise a plan, a\nsequence of actions that would allow him to reach the desired\ngoal.</b>\n\n<p>\nTo be able to plan, a system needs to be able to reason about\nthe individual and cumulative effects of a series of actions.</p>\n<ul>\n<li>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p></li>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into account\nthis locality of the effects of actions.</p></li>\n</ul>\n<br>\n\n<p>\n<em>We need to define a representation for two things:</em></p>\n<ul>\n<li>\n\n<p>\nHow will we represent the state of the world?</p></li>\n<li>\n\n<p>\nHow will we represent actions and their local effect on the world?</p></li>\n</ul>\n<br>\n\n<p>\nActions change the current state of the planning world, thereby\ncausing transitions to new states.</p>\n<ul>\n<li>\n\n<p>\nHowever an action does not normally change everything in the\ncurrent state, just some components of the state.</p></li>\n<li>\n\n<p>\nA good planning representation should therefore take into\naccount this locality of the effects of actions.</p></li>\n</ul>\n<br>\n\n<p>\n<em>Therefore, we need to be able to represent three states of the world:</em></p>\n<ul>\n<li>\n\n<p>\ninitial state</p></li>\n<li>\n\n<p>\ncurrent state</p></li>\n<li>\n\n<p>\ngoal state</p></li>\n</ul>\n<br>\nWith these 3 states, anyone can construct a planner that produces a outcome based on the input of the user.\n<br>\n\n<p>\nThere are many kind of planners, such as STRIPS, CLP(FD)and FRAME. This website will cover and walk through \nsome STRIPS style, and also briefly cover the implementaions of CLP(FD) and FRAME.</p><br>\n<h4> Credit to Dr. John. Kelleher of DIT for example and info. Complete slides and examples can be found <a href=\"http://www.comp.dit.ie/jkelleher/ai1labs/Tut12-Planning1/Tut12.pdf\">here</a>")).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',published,_G19912)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',published,true)).
retractall(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',title,_G19912)).
assertz(eav('481be28c-48ab-42b8-a724-bb8b105ff4db',title,"Introduction to Planning and Story Generation in SWI-Prolog")).
end.
begin.
end.
