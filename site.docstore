begin.
assertz(col(config,'8f38942e-9293-4f31-ac3c-7b0c17bd7420')).
assertz(eav('8f38942e-9293-4f31-ac3c-7b0c17bd7420',name,title)).
assertz(eav('8f38942e-9293-4f31-ac3c-7b0c17bd7420',value,'Untitled site')).
assertz(col(migration,'c7ff0977-65e3-457f-a241-1a615b92405b')).
assertz(eav('c7ff0977-65e3-457f-a241-1a615b92405b',description,'Inserts the initial config')).
assertz(eav('c7ff0977-65e3-457f-a241-1a615b92405b',name,bc_initial_config)).
end.
begin.
assertz(col(user,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',files,true)).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',fullname,'Admin')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',key,'a062927b-089a-4bcb-ac0f-aca58988a9e4')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',link,"")).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',password,'09bd34749085b3dd199080991c5a6d358b1e581aa5d63c8752d8c423faff1206')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',salt,'25381708-4303-4df1-aa93-1e874088ab53')).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',type,admin)).
assertz(eav('d67f244f-c861-41d6-a9bc-21b10630148f',username,'admin@example.com')).
assertz(col(migration,'62f47a3b-d743-4d62-aa6f-806e6e471b8c')).
assertz(eav('62f47a3b-d743-4d62-aa6f-806e6e471b8c',description,'Inserts the initial user')).
assertz(eav('62f47a3b-d743-4d62-aa6f-806e6e471b8c',name,bc_initial_user)).
end.
begin.
assertz(col(config,'ee83b5fe-5808-4e66-ae88-6e216594c4a2')).
assertz(eav('ee83b5fe-5808-4e66-ae88-6e216594c4a2',name,default_language)).
assertz(eav('ee83b5fe-5808-4e66-ae88-6e216594c4a2',value,en)).
assertz(col(migration,'9e78bf1d-0079-4e94-afc0-54fb52fe2753')).
assertz(eav('9e78bf1d-0079-4e94-afc0-54fb52fe2753',description,'Adds language to posts')).
assertz(eav('9e78bf1d-0079-4e94-afc0-54fb52fe2753',name,bc_add_language)).
end.
begin.
assertz(col(config,'46081e67-ba6e-4983-a778-8396659cc206')).
assertz(eav('46081e67-ba6e-4983-a778-8396659cc206',name,smtp_enabled)).
assertz(eav('46081e67-ba6e-4983-a778-8396659cc206',value,false)).
assertz(col(config,'725dbd62-1e3f-4c6a-a8ee-d1dc8c22b6db')).
assertz(eav('725dbd62-1e3f-4c6a-a8ee-d1dc8c22b6db',name,smtp_host)).
assertz(eav('725dbd62-1e3f-4c6a-a8ee-d1dc8c22b6db',value,localhost)).
assertz(col(config,'ceb0a1a4-efd6-4cc8-a3c0-9e813b994c15')).
assertz(eav('ceb0a1a4-efd6-4cc8-a3c0-9e813b994c15',name,smtp_user)).
assertz(eav('ceb0a1a4-efd6-4cc8-a3c0-9e813b994c15',value,user)).
assertz(col(config,'7604dd4d-8e30-40c4-ae0b-23b3f05660c6')).
assertz(eav('7604dd4d-8e30-40c4-ae0b-23b3f05660c6',name,smtp_password)).
assertz(eav('7604dd4d-8e30-40c4-ae0b-23b3f05660c6',value,password)).
assertz(col(config,'734bcc37-b5ce-4f62-ac7c-6b6a1bb9ea49')).
assertz(eav('734bcc37-b5ce-4f62-ac7c-6b6a1bb9ea49',name,smtp_auth)).
assertz(eav('734bcc37-b5ce-4f62-ac7c-6b6a1bb9ea49',value,login)).
assertz(col(migration,'6b37e35d-3917-42e7-a786-d70a04ac92f6')).
assertz(eav('6b37e35d-3917-42e7-a786-d70a04ac92f6',description,'Adds SMTP settings')).
assertz(eav('6b37e35d-3917-42e7-a786-d70a04ac92f6',name,bc_smtp_settings)).
end.
begin.
assertz(col(entry,'4fe426fe-9032-4661-aeb0-18be269670dd')).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',commenting,true)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',content,"My first Blog-Core site")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',content_type,markdown)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',date_updated,1421884800)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',description,"")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',html,"\n\n<p>\nMy first Blog-Core site</p>")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',language,"en")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',published,false)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',slug,about)).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',tags,[])).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',title,"About")).
assertz(eav('4fe426fe-9032-4661-aeb0-18be269670dd',type,block)).
end.
begin.
assertz(col(entry,'88daf9ee-74b1-40cc-a3f3-a867cfbfb398')).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',author,'d67f244f-c861-41d6-a9bc-21b10630148f')).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',commenting,true)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"Hello World")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content_type,markdown)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1421884800)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',description,"")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"\n\n<p>\nHello World</p>")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',language,"en")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',published,false)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',slug,hello)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',tags,[])).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',title,"hello")).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',type,page)).
end.
begin.
assertz(col(user,'d9556236-364e-4796-a7e8-3337e82660f3')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',files,true)).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',fullname,'Yingbai He')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',key,'c3ff8e02-9bd2-474f-a2a6-fa38e1101bdb')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',link,"")).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',password,f455a78de278c5d54d32220e4a18477ef2cec14bf621ed4ff6849621b1f1bb68)).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',salt,'193d8e04-c862-4e12-af29-b4ddc8f0b50a')).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',type,admin)).
assertz(eav('d9556236-364e-4796-a7e8-3337e82660f3',username,'hyb175@qq.com')).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,_G2756)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1422835200)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',slug,_G2756)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',slug,tutorial)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',title,_G2756)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',title,"Tutorial")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G53696)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t\t<TITLE>Your Title Here</TITLE>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G53696)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t\t<TITLE>Your Title Here</TITLE>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t\t\t<a href=\"http://www.yb-he-world.com/#!/\">Link Name</a>\n\t\t\tis a link to another nifty site\n\t\t\t<H1>This is a Header</H1>\n\t\t\t<H2>This is a Medium Header</H2>\n\t\t\tSend me mail at \n\t\t\t<a href=\"mailto:support@yourcompany.com\">\n\t\t\tsupport@yourcompany.com</a>.\n\t\t\t</br>\n\t\t\t<img src=\"/image.png\">\n\t\t\t<P> This is a new paragraph!\n\t\t\t</P> <B>This is a new paragraph!</B>\n\t\t\t<BR> <B><I>This is a new sentence without a paragraph break, in bold italics.</I></B>\n\t\t<HR>\n\t</BODY>\n</HTML>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G19429)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G19429)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G10020)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G10020)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<link rel=\"icon\" href=\"/favicon.ico\" type=\"image/png\"/>\n\t<HEAD>\n\t</HEAD>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G5506)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G5506)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n                    plan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G8092)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</code></p>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G8092)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/code&gt;&lt;/p&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G10567)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</code>\n\n\t\t<code>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\t</code>\n\t\t\t\n\t\t<code>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</code>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G10567)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<code>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</code>\n\n<pre>\n<code>\t&lt;code&gt;\n\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t&lt;/code&gt;\n\t\t\n\t&lt;code&gt;\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/code&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G9665)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G9665)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/pre&gt;&lt;/p&gt;\n\n&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G11751)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\n\t</BODY>\n</HTML>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G11751)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<HTML>\n\t<BODY BGCOLOR=\"FFFFFF\">\n\t\t<HR>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<HR>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\n<pre>\n<code>&lt;/BODY&gt;</code>\n</pre>\n\n<p>\n</HTML></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G118365)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\n\t\t\tfail.\n\n\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\n\t\t\tfail.\n\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\n\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\n\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G118365)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\n<pre>\n<code>\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/pre&gt;&lt;/p&gt;\n\t&lt;p&gt;All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.&lt;/p&gt;\n\t&lt;p&gt;Adding the initial conditions stores the initialstate as nodes in the database. &lt;/p&gt;\n\t&lt;pre&gt;\n\tadd_initial_conditions([]).\n\tadd_initial_conditions([Pred|Conditions]):-\n\t\tadd_plan_graph(0, add, Pred, start),\n\t\tadd_initial_conditions(Conditions).&lt;/pre&gt;\n\t&lt;p&gt;We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. &lt;/p&gt;\n\t&lt;p&gt;Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. &lt;/p&gt;\n\t&lt;pre&gt;\n\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\tN1 is N-1,\n\t\t%% Check if FinalState Conditions have been satisfied \n\t        %%    and no mutual exclusion conditions have been violated\n\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t!.\n\n\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t% Add no-ops\n\t\tadd_no_op_nodes(N),\n\n\t\tfail.\n\n\n\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\tcan(Action, PreConditions, Domain),\n\t\tNPrev is N-1,\n\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\n\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(DelPreConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t    )\n\t\t),\n\n\t\t\n\t\tadds(Action, AddConditions, _, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(AddConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t    )\n\t\t),\n\n\n\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t%\tnl, write(\"Added Action: \"), write(Action),\n\t%\tnl,\n\n\t\tfail.\n\n\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t% Propagate mutual exclusions\n\t\tmutex(N),\n\n\t\tN1 is N+1,\n\t\t!,\n\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t!.\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;pre&gt;\n\tPrevActions, Plan):-\n\t\tN &gt; 0,\n\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\n\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\tlist_to_set(PreConds, MidState),\n\n\t\tnl, write(' Level  '), write(N),\n\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\tN1 is N-1,\n\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.&lt;/p&gt;\n\t&lt;p&gt;The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.&lt;/p&gt;\n\t&lt;p&gt;There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.&lt;/p&gt;\n\t&lt;p&gt;Finally, we can write the plan out to the screen by write_plan/1. &lt;/p&gt;\n\t&lt;hr&gt;\n\t&lt;p&gt;We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\tThe rocket_graph contains the defintion of domain and the available actions.\n\tThis example wants to move the cargos from one city to another.\n\tWe first define the knowledge base of rocket, place and cargo.&lt;/p&gt;\n\t&lt;pre&gt;\n\tplace(london).\n\tplace(paris).\n\tcargo(a).\n\tcargo(b).\n\tcargo(c).\n\tcargo(d).\n\tcargo(e).\n\t&lt;/pre&gt;\n\t&lt;p&gt;Then we define the available actions of move, unload and load the rocket.\n\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\tSo move(Rocket, From, To) would look like the following.&lt;/p&gt;\n\t&lt;pre&gt;\n\t%move(Rocket, From, To).\n\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\trocket(Rocket),\n\t\tplace(From),\n\t\tplace(To),\n\t\tFrom \\= To.\n\n\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\trocket(Rocket),\n\t\tplace(To).\n\n\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\trocket(Rocket),\n\t\tplace(From).\n\n\tLet's test out the planner\n\ttest(P) :-\n\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t     [at(a, paris)], rocket,\n\t\t     P).\n\t&lt;/pre&gt;\n\t&lt;p&gt;We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.&lt;/p&gt;\n\t&lt;p&gt;The output is\n\t&lt;pre&gt;?- test(P).\n\n\tFeasible Plan found at level 4\n\t Level  4\n\tActions :\n\t[unload(rocket1,paris,a)]\n\tState   :\n\t[at(a,paris)]\n\n\n\t Level  3\n\tActions :\n\t[no_op(11),move(rocket1,london,paris)]\n\tState   :\n\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t Level  2\n\tActions :\n\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\tState   :\n\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t Level  1\n\tActions :\n\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\tState   :\n\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\tStep 1:\n\t        move(rocket1,paris,london)\n\n\tStep 2:\n\t        load(rocket1,london,a)\n\n\tStep 3:\n\t        move(rocket1,london,paris)\n\n\tStep 4:\n\t        unload(rocket1,paris,a)\n\n\n\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t&lt;/pre&gt;&lt;/p&gt;\n\n&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G122947)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</pre>\n\n\t\t<pre>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\t</pre>\n\n\t\t<pre>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\n\t\t\tfail.\n\n\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\n\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\n\t\t\tfail.\n\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\n\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\n\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G122947)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),</pre>\n\n<pre>\n<code>\t&lt;pre&gt;\n\t\tretractall(plan_graph_del(_, _, _)),\n\t\tretractall(plan_graph_add(_, _, _)),\n\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t&lt;/pre&gt;\n\n\t&lt;pre&gt;\n\t\tassert(no_op_count(0)),\n\t\tadd_initial_conditions(InitialState),\n\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\tremove_no_ops(PlanT, Plan),\n\t\tnl, nl, write_plan(Plan), nl.\n\t&lt;/pre&gt;&lt;/p&gt;\n\t&lt;p&gt;All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.&lt;/p&gt;\n\t&lt;p&gt;Adding the initial conditions stores the initialstate as nodes in the database. &lt;/p&gt;\n\t&lt;pre&gt;\n\tadd_initial_conditions([]).\n\tadd_initial_conditions([Pred|Conditions]):-\n\t\tadd_plan_graph(0, add, Pred, start),\n\t\tadd_initial_conditions(Conditions).&lt;/pre&gt;\n\t&lt;p&gt;We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. &lt;/p&gt;\n\t&lt;p&gt;Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. &lt;/p&gt;\n\t&lt;pre&gt;\n\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\tN1 is N-1,\n\t\t%% Check if FinalState Conditions have been satisfied \n\t        %%    and no mutual exclusion conditions have been violated\n\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t!.\n\n\tgenerate_graph_nodes(N, _, _, _Domain):-\n\n\t\t% Add no-ops\n\t\tadd_no_op_nodes(N),\n\n\t\tfail.\n\n\n\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\tcan(Action, PreConditions, Domain),\n\t\tNPrev is N-1,\n\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\n\t\t\n\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(DelPreConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t    )\n\t\t),\n\n\t\t\n\t\tadds(Action, AddConditions, _, Domain),\n\t\t%% Instantiation Check\n\t\t( ground(AddConditions) \n\t           -&gt; true\n\t            ; ( \n\t\t        nl, \n\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\tnl,\n\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t    )\n\t\t),\n\n\n\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\n\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\n\t%\tnl, write(\"Added Action: \"), write(Action),\n\t%\tnl,\n\n\t\tfail.\n\n\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\n\t\t% Propagate mutual exclusions\n\t\tmutex(N),\n\n\t\tN1 is N+1,\n\t\t!,\n\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t!.\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;p&gt;The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. &lt;/p&gt;\n\t&lt;pre&gt;\n\tPrevActions, Plan):-\n\t\tN &gt; 0,\n\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\n\t\t\n\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\tlist_to_set(PreConds, MidState),\n\n\t\tnl, write(' Level  '), write(N),\n\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\n\t\tN1 is N-1,\n\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t&lt;/pre&gt;\n\t&lt;p&gt;The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.&lt;/p&gt;\n\t&lt;p&gt;The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.&lt;/p&gt;\n\t&lt;p&gt;There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.&lt;/p&gt;\n\t&lt;p&gt;Finally, we can write the plan out to the screen by write_plan/1. &lt;/p&gt;\n\t&lt;hr&gt;\n\t&lt;p&gt;We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\tThe rocket_graph contains the defintion of domain and the available actions.\n\tThis example wants to move the cargos from one city to another.\n\tWe first define the knowledge base of rocket, place and cargo.&lt;/p&gt;\n\t&lt;pre&gt;\n\tplace(london).\n\tplace(paris).\n\tcargo(a).\n\tcargo(b).\n\tcargo(c).\n\tcargo(d).\n\tcargo(e).\n\t&lt;/pre&gt;\n\t&lt;p&gt;Then we define the available actions of move, unload and load the rocket.\n\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\tSo move(Rocket, From, To) would look like the following.&lt;/p&gt;\n\t&lt;pre&gt;\n\t%move(Rocket, From, To).\n\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\trocket(Rocket),\n\t\tplace(From),\n\t\tplace(To),\n\t\tFrom \\= To.\n\n\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\trocket(Rocket),\n\t\tplace(To).\n\n\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\trocket(Rocket),\n\t\tplace(From).\n\n\tLet's test out the planner\n\ttest(P) :-\n\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t     [at(a, paris)], rocket,\n\t\t     P).\n\t&lt;/pre&gt;\n\t&lt;p&gt;We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.&lt;/p&gt;\n\t&lt;p&gt;The output is\n\t&lt;pre&gt;?- test(P).\n\n\tFeasible Plan found at level 4\n\t Level  4\n\tActions :\n\t[unload(rocket1,paris,a)]\n\tState   :\n\t[at(a,paris)]\n\n\n\t Level  3\n\tActions :\n\t[no_op(11),move(rocket1,london,paris)]\n\tState   :\n\t[at(rocket1,paris),in(a,rocket1)]\n\n\n\t Level  2\n\tActions :\n\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\tState   :\n\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\n\n\t Level  1\n\tActions :\n\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\tState   :\n\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\n\n\n\n\tStep 1:\n\t        move(rocket1,paris,london)\n\n\tStep 2:\n\t        load(rocket1,london,a)\n\n\tStep 3:\n\t        move(rocket1,london,paris)\n\n\tStep 4:\n\t        unload(rocket1,paris,a)\n\n\n\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t&lt;/pre&gt;&lt;/p&gt;\n\n&lt;/body&gt;</code>\n</pre>\n\n<p>\n</html></p>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G70656)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G70656)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G53072)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G53072)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),\t\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)\n\t\tStep 2:\n\t\t        load(rocket1,london,a)\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
end.
begin.
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,_G72419)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',content,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,_G72419)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',date_updated,1422921600)).
retractall(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,_G72419)).
assertz(eav('88daf9ee-74b1-40cc-a3f3-a867cfbfb398',html,"<html>\n\t<body BGCOLOR=\"FFFFFF\">\n\t\t<hr>\n\t\t<h1>STRIPS-style planner</h1>\n\t\t<p>STRIPS stands for Stanford Research Institute Problem Solver, which is an automated planner popular in artificial intelligence.</p>\n\t\t<p>Let's take a look at one of a large amount of different implementation of the STRIPS planner.</p>\n\t\t<p>This implementation is provided by Dr. Suresh Manandhar from the University of York Computer Science department and slightly modified by Dr. Pierre Andrews.This is an open source implementation, which is why we are able to use it for this tutorial. </p>\n\t\t<hr>\n\t\t<p>Let's start with the main predicate plan/4. There are InitialState, FinalState, Domain, Plan in the predicate. </p>\n\t\t<p>InitialState contains the initial conditions and the FinalState contains the states after the final goal is reached. Domain contains the available actions and the Plan consists the set of actions to get from the InitialState to FinalState.</p>\n\t\t<p><pre>\n\t\tplan(InitialState, FinalState, Domain, Plan):-\n\t\t\tretractall(no_op_count(_)),\n\t\t\tretractall(mutex_action(_, _, _)),\n\t\t\tretractall(mutex_condition(_, _, _)),<br>\n\t\t\tretractall(plan_graph_del(_, _, _)),\n\t\t\tretractall(plan_graph_add(_, _, _)),\n\t\t\tretractall(plan_graph_pre(_, _, _)),<br>\n\t\t\tassert(no_op_count(0)),\n\t\t\tadd_initial_conditions(InitialState),\n\t\t\tgenerate_graph_nodes(1, FinalState, FinalLevel, Domain),\n\t\t\tfind_plan(FinalLevel, FinalState, InitialState, [], PlanT),\n\t\t\tremove_no_ops(PlanT, Plan),\n\t\t\tnl, nl, write_plan(Plan), nl.\n\t\t</pre></p>\n\t\t<p>All the retractall statemnets are used to remove the data currently stored in the database. Firstly, we need to add the initial conditions to the graph, which is included in the InitialState. Then we can generate the graph of mapping from InitialState to FinalState with a given domain. We can then find the plan on the graph.</p>\n\t\t<p>Adding the initial conditions stores the initialstate as nodes in the database. </p>\n\t\t<pre>\n\t\tadd_initial_conditions([]).\n\t\tadd_initial_conditions([Pred|Conditions]):-\n\t\t\tadd_plan_graph(0, add, Pred, start),\n\t\t\tadd_initial_conditions(Conditions).</pre>\n\t\t<p>We can see that add_plan_graph/4 actually calls assert, which insert the nodes as facts to the prolog database. </p>\n\t\t<p>Generate_graph_nodes search for the available actions under the current states and add the next states under the new actions as nodes into the graph. </p>\n\t\t<pre>\n\t\tgenerate_graph_nodes( N, FinalState, N1, _Domain):-\n\t\t\tN1 is N-1,\n\t\t\t%% Check if FinalState Conditions have been satisfied \n\t\t        %%    and no mutual exclusion conditions have been violated\n\t\t\tget_nonmutex_addconds(FinalState, N1, []),\n\t\t\tnl, write('Feasible Plan found at level '), write(N1),\n\t\t\t!.<br>\n\t\tgenerate_graph_nodes(N, _, _, _Domain):-\n\t\t\t% Add no-ops\n\t\t\tadd_no_op_nodes(N),\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, _, _, Domain):-\n\t\t\tcan(Action, PreConditions, Domain),\n\t\t\tNPrev is N-1,<br>\n\t\t\tget_nonmutex_addconds(PreConditions, NPrev, []),\t\t\t\t\n\t\t\tdeletes(Action, DelPreConditions, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(DelPreConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Del Conditions: '), write(DelPreConditions), nl\n\t\t\t    )\n\t\t\t),<br>\t\t\n\t\t\tadds(Action, AddConditions, _, Domain),\n\t\t\t%% Instantiation Check\n\t\t\t( ground(AddConditions) \n\t\t           -> true\n\t\t            ; ( \n\t\t\t        nl, \n\t\t\t\twrite('Action not fully instantiated '), write(Action),\n\t\t\t\tnl,\n\t\t\t\twrite('Add Conditions: '), write(AddConditions), nl\n\t\t\t    )\n\t\t\t),<br\n\t\t\tadd_graph_nodes(PreConditions, Action, N, pre),\n\t\t\tadd_graph_nodes(DelPreConditions, Action, N, del),\n\t\t\tadd_graph_nodes(AddConditions, Action, N, add),\n\t\t%\tnl, write(\"Added Action: \"), write(Action),\n\t\t%\tnl,\n\t\t\tfail.<br>\n\t\tgenerate_graph_nodes(N, FinalState, FinalLevel, Domain):-\n\t\t\t% Propagate mutual exclusions\n\t\t\tmutex(N),\n\t\t\tN1 is N+1,\n\t\t\t!,\n\t\t\tgenerate_graph_nodes(N1, FinalState, FinalLevel, Domain),\n\t\t\t!.\n\t\t\t</pre>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<p>The generate_graph_nodes/4 predicates also ensure mutual exclusion, which makes sure that the graph does not contain loops. The process stops when we reaches the final states. </p>\n\t\t<pre>\n\t\tPrevActions, Plan):-\n\t\t\tN > 0,\n\t\t\tfind_current_level_actions(N, CurrentState,  [], CurLevelNActions, []),\t\n\t\t\tfindall(Cond,(member(Action,CurLevelNActions), plan_graph(N, pre, Cond, Action)), PreConds),\n\t\t\tlist_to_set(PreConds, MidState),\n\t\t\tnl, write(' Level  '), write(N),\n\t\t\tnl, write('Actions : '), nl, write(CurLevelNActions),\n\t\t\tnl, write('State   : '), nl, write(CurrentState), nl,nl,\n\t\t\tN1 is N-1,\n\t\t\tfind_plan(N1, MidState, InitialState, [CurLevelNActions|PrevActions], Plan).\n\t\t\t</pre>\n\t\t<p>The predicates search for available actions at the current level and list the next states in parallel. Then they try to find the next level actions by call on find_plan/4 again.</p>\n\t\t<p>The predicates use the built-in predicates provided by Prolog - findall/4 and list_to_set/2.</p>\n\t\t<p>There can be no_op(X) inserted in the plan because at some level there is no possible moves. As a result, we want to remove the no_ops.</p>\n\t\t<p>Finally, we can write the plan out to the screen by write_plan/1. </p>\n\t\t<hr>\n\t\t<p>We now have the planner. Let's look at a demostration of the planner using one of the graph provided by graphplanner.\n\t\tThe rocket_graph contains the defintion of domain and the available actions.\n\t\tThis example wants to move the cargos from one city to another.\n\t\tWe first define the knowledge base of rocket, place and cargo.</p>\n\t\t<pre>\n\t\tplace(london).\n\t\tplace(paris).\n\t\tcargo(a).\n\t\tcargo(b).\n\t\tcargo(c).\n\t\tcargo(d).\n\t\tcargo(e).\n\t\t</pre>\n\t\t<p>Then we define the available actions of move, unload and load the rocket.\n\t\tFor each action, we define the condition when the action can take place and then the conditions that can be added or deleted from the conditions current conditions after performing the action.\n\t\tSo move(Rocket, From, To) would look like the following.</p>\n\t\t<pre>\n\t\t%move(Rocket, From, To).\n\t\tcan(move(Rocket,From,To),[at(Rocket,From), has_fuel(Rocket)], rocket) :- %vehicle move only within city\n\t\t\trocket(Rocket),\n\t\t\tplace(From),\n\t\t\tplace(To),\n\t\t\tFrom \\= To.<br>\n\t\tadds(move(Rocket,_From,To),[at(Rocket, To)], at(Rocket,To), rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(To).<br>\n\t\tdeletes(move(Rocket,From,_To),[at(Rocket,From)], rocket):-\n\t\t\trocket(Rocket),\n\t\t\tplace(From).\n\t\tLet's test out the planner\n\t\ttest(P) :-\n\t\t\tplan([at(a, london), at(rocket1, paris), has_fuel(rocket1)],\n\t\t\t     [at(a, paris)], rocket,\n\t\t\t     P).\n\t\t</pre>\n\t\t<p>We provide the planner with the initial conditions of [at(a, london), at(rocket1, paris), has_fuel(rocket1)], the final condition of [at(a, paris)], the domain(rocket), and the planner should fill in the plan P.</p>\n\t\t<p>The output is\n\t\t<pre>?- test(P).\n\t\tFeasible Plan found at level 4\n\t\t Level  4\n\t\tActions :\n\t\t[unload(rocket1,paris,a)]\n\t\tState   :\n\t\t[at(a,paris)]<br>\n\t\t Level  3\n\t\tActions :\n\t\t[no_op(11),move(rocket1,london,paris)]\n\t\tState   :\n\t\t[at(rocket1,paris),in(a,rocket1)]<br>\n\t\t Level  2\n\t\tActions :\n\t\t[no_op(5),no_op(6),load(rocket1,london,a)]\n\t\tState   :\n\t\t[in(a,rocket1),at(rocket1,london),has_fuel(rocket1)]<br>\n\t\t Level  1\n\t\tActions :\n\t\t[no_op(0),move(rocket1,paris,london),no_op(2)]\n\t\tState   :\n\t\t[has_fuel(rocket1),at(rocket1,london),at(a,london)]<br><br>\n\t\tStep 1:\n\t\t        move(rocket1,paris,london)<br>\n\t\tStep 2:\n\t\t        load(rocket1,london,a)<br>\n\t\tStep 3:\n\t\t        move(rocket1,london,paris)<br>\n\t\tStep 4:\n\t\t        unload(rocket1,paris,a)<br><br>\n\t\tP = [[move(rocket1, paris, london)], [load(rocket1, london, a)], [move(rocket1, london, paris)], [unload(rocket1, paris, a)]].\n\t\t</pre></p>\n\t</body>\n</html>")).
end.
